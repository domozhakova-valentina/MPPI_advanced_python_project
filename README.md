# MPPI_advanced_python_project
Реализация алгоритма стохастического оптимального управления Model Predictive Path Integral с использованием JAX, Python + Pybind11 + C++ и Python + Numpy. Алгоритм находит решение для задачи балансировки перевернутого маятника.

## Содержание
1. [Обзор проекта](#обзор-проекта)
2. [Описание алгоритма](#реализации-алгоритма)
3. [План работы](#план-работы)
4. [Архитектура системы](#архитектура-системы)
5. [Структура проекта](#структура-проекта)
6. [Визуализация](#визуализация)
7. [Тестирование](#тестирование)
8. [Развертывание](#развертывание)

## Обзор проекта

### Основные задачи
1. Реализация алгоритма MPPI на трех технологических стеках:
* JAX
* Python + Pybind11 + C++
* Python + Numpy
2. Создание единого интерфейса для всех реализаций
3. Валидация корректности работы алгоритмов
4. Сравнение производительности реализаций
5. Докеризация и развертывание в облаке

### Что видит пользователь

- **Веб-интерфейс** с визуализацией работы маятника в реальном времени
- **Возможность настройки** параметров системы и алгоритма
- **Графики сравнения** производительности разных реализаций алгоритма
- **Статистику работы** и метрики

## Описание алгоритма
### Что такое задача перевёрнутого маятника
Есть тележка, которая может двигаться влево-вправо, и закреплённый на ней маятник, удерживаемый в вертикальном положении вверх. Т.к. данная система неустойчива и маятник будет падать при малейшем отклонении, то задача управления — балансировать маятник вертикально, двигая тележку.

<img width="298" height="328" alt="image" src="https://github.com/user-attachments/assets/5bc7a643-2e9d-4b5c-8f59-e590f6fdabb3" />

### В чём суть алгоритм MPPI и как он может помочь в этой задаче
Алгоритм MPPI используется для управления нелинейными системами с возмущениями (т.е. системами, на работу которых воздействуют внешние или внутренние факторы, не учитываемые напрямую в основной модели, например, для маятника это может быть порыв ветра или погрешность в измерении его массы). Такие системы описываются сложными дифференциальными уравнениями, которые обычно не решаются напрямую. Поэтому чтобы спрогнозировать состояние объекта в следующий момент времени (куда и с какой силой двигать тележку), алгоритм MPPI получает на вход данные о текущем состоянии системы (с небольшими погрешностями измерения), затем просчитывает различные случайно выбранные траектории и считает стоимость $s_i$ каждой по заранее написанной cost_function. После этого он рассчитывает вес каждой стоимости (чем меньше стоимость тем больше вес):

$$ w_i = e^{\frac{s_i}{\lambda}$$, где $\lambda$ - это выбранный нами параметр

Затем рассчитывает положение, куда должна переместиться тележка, как "текущее положение + сумма всех траекторий, домноженных на их вес, делённых на сумму всех весов":

$$u_{new} = u + \frac{\sum{w_i*u_i}}{\sum{w_i}}$$

и отправляет его системе, которая перемещается по этой траектории. Затем система передаёт информацию о своём текущем состоянии и процесс повторяется заново. 
Преимущество данного метода перед прямыми вычислениями в том, что можно распараллелить подсчёт траекторий, поэтому алгоритм будет работать быстрее, что важно для таких задач, как балансировка маятника, т.к. тележка должна реагировать быстро, чтобы маятник не упал.

## План работы

<img width="320" height="320" alt="image" src="https://github.com/user-attachments/assets/9116fc6b-6396-4001-b4b3-31c6757e85b4" />

### Шаг 1: Подготовка инфраструктуры (4 дня)
- [ ] Настройка структуры проекта и CI/CD - 1 день
- [ ] Создание базовых интерфейсов и абстрактных классов - 1 день
- [ ] Настройка тестового окружения - 1 день
- [ ] Докеризация базовых компонентов - 1 день

### Шаг 2: Реализация алгоритмов (3 дня)
- [ ] NumPy реализация - 1 день
- [ ] JAX реализация с оптимизацией - 1 день
- [ ] C++ реализация с PyBind11 - 1 день

### Шаг 3: Интеграция и тестирование (3 дня)
- [ ] Создание единого API - 1 день
- [ ] Написание тестов - 1 день
- [ ] Бенчмаркинг производительности - 1 день

### Шаг 4: Визуализация и развертывание (3 дня)
- [ ] Веб-интерфейс с визуализацией - 2 день
- [ ] Развертывание в облаке - 1 день

**Общее время: примерно 13 дней**

## Архитектура системы

```mermaid
graph TB
    A[Web Interface] --> B[FastAPI Application]
    B --> C[MPPI Controller]
    C --> D[JAX Implementation]
    C --> E[NumPy Implementation]
    C --> F[C++ Implementation]
    D --> G[Inverted Pendulum Model]
    E --> G
    F --> G
    G --> H[Results Collector]
    H --> I[Performance Analytics]
    H --> J[Visualization Engine]
```

### Описание

1. **Пользователь** через Web Interface настраивает эксперимент
2. **FastAPI** валидирует запрос и передаёт в MPPI Controller
3. **MPPI Controller** выбирает нужную реализацию и запускает симуляцию
4. **Выбранная реализация** взаимодействует с общей моделью маятника
5. **Results Collector** агрегирует данные со всех симуляций
6. **Performance Analytics** анализирует метрики производительности
7. **Visualization Engine** создаёт графики и отчёты
8. **Результаты** возвращаются через FastAPI в Web Interface

## Структура проекта

```
project/
├── src/
│   ├── core/                    # Абстрактные классы и интерфейсы
│   │   ├── base_controller.py
│   │   ├── dynamics.py
│   │   └── cost_function.py
│   ├── implementations/
│   │   ├── jax/                # JAX реализация
│   │   ├── numpy/              # NumPy реализация
│   │   └── cpp/                # C++ реализация
│   └── models/
│       └── inverted_pendulum.py # Физическая модель системы
├── tests/                      # Тесты всех компонентов
├── benchmarks/                 # Бенчмарки производительности
├── docker/                     # Docker конфигурации
├── docs/                       # Документация
└── examples/                   # Примеры использования
```

## Визуализация
**Статические графики и анимации с помощью matplotlib**

1. `plot_single_simulation()` - детальная визуализация одной симуляции
2. `plot_comparison()` - сравнение всех реализаций
3. `create_animation()` - анимация движения маятника
4. `plot_performance_metrics()` - метрики производительности

## Тестирование
Реализация 4 различных групп тестов
- **Модульные тесты** - проверка отдельных компонентов
- **Интеграционные тесты** - взаимодействие между компонентами и API
- **Функциональные тесты** - проверка корректности работы алгоритма на задаче маятника
- **Тесты производительности** - оценка скорости и памяти для всех реализаций

## Развёртывание
In development...

(Планируется упаковка в Docker, но нужно разобраться, как это работает)
