# MPPI_advanced_python_project
Реализация алгоритма стохастического оптимального управления Model Predictive Path Integral с использованием JAX, Python + Pybind11 + C++ и Python + Numpy. Алгоритм находит решение для задачи балансировки перевернутого маятника.

## Содержание
1. [Обзор проекта](#обзор-проекта)
2. [Описание алгоритма](#реализации-алгоритма)
3. [План работы](#план-работы)
4. [Архитектура системы](#архитектура-системы)
5. [Структура проекта](#структура-проекта)
6. [Визуализация](#визуализация)
7. [Тестирование](#тестирование)
8. [Развертывание](#развертывание)

## Обзор проекта

### Основные задачи
1. Реализация алгоритма MPPI на трех технологических стеках:
* JAX
* Python + Pybind11 + C++
* Python + Numpy
2. Создание единого интерфейса для всех реализаций
3. Валидация корректности работы алгоритмов
4. Сравнение производительности реализаций
5. Докеризация и развертывание в облаке

### Что видит пользователь

- **Веб-интерфейс** с визуализацией работы маятника в реальном времени
- **Возможность настройки** параметров системы и алгоритма
- **Графики сравнения** производительности разных реализаций алгоритма
- **Статистику работы** и метрики

## Описание алгоритма
### Что такое задача перевёрнутого маятника
Есть тележка, которая может двигаться влево-вправо, и закреплённый на ней маятник, удерживаемый в вертикальном положении вверх. Т.к. данная система неустойчива и маятник будет падать при малейшем отклонении, то задача управления — балансировать маятник вертикально, двигая тележку.

<img width="298" height="328" alt="image" src="https://github.com/user-attachments/assets/5bc7a643-2e9d-4b5c-8f59-e590f6fdabb3" />

### В чём суть алгоритм MPPI и как он может помочь в этой задаче
Алгоритм MPPI используется для управления нелинейными системами с возмущениями и неопределённостью (т.е. системами, на работу которых воздействуют внешние или внутренние факторы, не учитываемые напрямую в модели: например, для маятника это может быть трение, порыв ветра или погрешность датчиков). Такие системы описываются сложными дифференциальными уравнениями, и найти точное оптимальное управление для них очень трудно. Алгоритм MPPI предлагает приближённое, но достаточно эффективное решение.

Чтобы спрогнозировать состояние объекта в следующий момент времени (куда и с какой силой двигать тележку), алгоритм MPPI получает на вход данные о текущем состоянии системы (положение и скорость тележки, угол и скорость маятника). Затем на $T$ шагов вперёд генерирует $K$ различных случайных последовательностей сил, применяемых к тележке. Эти последовательности получаются добавлением случайных «возмущений» $\epsilon_i$ к текущей наилучшей траектории управления

Для каждой такой последовательности алгоритм с помощью модели динамики системы (тех самых уравнений) просчитывает, какая траектория состояния получится. Затем для каждой траектории считается стоимость $s_i$ по заранее заданной функции cost_function. Эта функция «штрафует» за нежелательные состояния (например, большое отклонение маятника от вертикали) и за большие затраты усилий.

$$w_i = \exp\left( -\frac{1}{\lambda} (s_i - \min_j s_j) \right)$$

где $\lambda$ — это выбранный нами параметр. Он регулирует, насколько сильно мы предпочитаем траектории с низкой стоимостью. Вычитание минимальной стоимости ($\min_j s_j$) необходимо для численной устойчивости вычислений.

Далее все сгенерированные последовательности сил усредняются с учётом их весов, и новая оптимальная траектория управления (последовательность сил на $T$ шагов вперёд) вычисляется так:

$$u_{new} = u_{current} + \frac{\sum_{i=1}^{K} w_i \cdot \epsilon_i}{\sum_{i=1}^{K} w_i}$$

Затем на реальную систему (тележку) подаётся только первая сила из обновлённой последовательности $u_{new}$. После этого система измеряет своё новое состояние, текущая траектория сдвигается, и весь цикл повторяется.

Преимущество MPPI в том, что просчёт тысяч случайных траекторий можно легко распараллелить (например, на GPU). Поэтому алгоритм успевает найти хорошее решение очень быстро, что критически важно для таких задач, как балансировка маятника, где тележка должна реагировать мгновенно, чтобы маятник не упал.

### Как это реализуется в коде


## План работы

<img width="320" height="320" alt="image" src="https://github.com/user-attachments/assets/9116fc6b-6396-4001-b4b3-31c6757e85b4" />

### Шаг 1: Подготовка инфраструктуры (4 дня)
- [ ] Настройка структуры проекта и CI/CD - 1 день
- [ ] Создание базовых интерфейсов и абстрактных классов - 1 день
- [ ] Настройка тестового окружения - 1 день
- [ ] Докеризация базовых компонентов - 1 день

### Шаг 2: Реализация алгоритмов (3 дня)
- [ ] NumPy реализация - 1 день
- [ ] JAX реализация с оптимизацией - 1 день
- [ ] C++ реализация с PyBind11 - 1 день

### Шаг 3: Интеграция и тестирование (3 дня)
- [ ] Создание единого API - 1 день
- [ ] Написание тестов - 1 день
- [ ] Бенчмаркинг производительности - 1 день

### Шаг 4: Визуализация и развертывание (3 дня)
- [ ] Веб-интерфейс с визуализацией - 2 день
- [ ] Развертывание в облаке - 1 день

**Общее время: примерно 13 дней**

## Архитектура системы

```mermaid
graph TB
    A[Web Interface] --> B[FastAPI Application]
    B --> C[MPPI Controller]
    C --> D[JAX Implementation]
    C --> E[NumPy Implementation]
    C --> F[C++ Implementation]
    D --> G[Inverted Pendulum Model]
    E --> G
    F --> G
    G --> H[Results Collector]
    H --> I[Performance Analytics]
    H --> J[Visualization Engine]
```

### Описание

1. **Пользователь** через Web Interface настраивает эксперимент
2. **FastAPI** валидирует запрос и передаёт в MPPI Controller
3. **MPPI Controller** выбирает нужную реализацию и запускает симуляцию
4. **Выбранная реализация** взаимодействует с общей моделью маятника
5. **Results Collector** агрегирует данные со всех симуляций
6. **Performance Analytics** анализирует метрики производительности
7. **Visualization Engine** создаёт графики и отчёты
8. **Результаты** возвращаются через FastAPI в Web Interface

## Структура проекта

```
project/
├── src/
│   ├── core/                    # Абстрактные классы и интерфейсы
│   │   ├── base_controller.py
│   │   ├── dynamics.py
│   │   └── cost_function.py
│   ├── implementations/
│   │   ├── jax/                # JAX реализация
│   │   ├── numpy/              # NumPy реализация
│   │   └── cpp/                # C++ реализация
│   └── models/
│       └── inverted_pendulum.py # Физическая модель системы
├── tests/                      # Тесты всех компонентов
├── benchmarks/                 # Бенчмарки производительности
├── docker/                     # Docker конфигурации
├── docs/                       # Документация
└── examples/                   # Примеры использования
```

## Визуализация
**Статические графики и анимации с помощью matplotlib**

1. `plot_single_simulation()` - детальная визуализация одной симуляции
2. `plot_comparison()` - сравнение всех реализаций
3. `create_animation()` - анимация движения маятника
4. `plot_performance_metrics()` - метрики производительности

## Тестирование
Реализация 4 различных групп тестов
- **Модульные тесты** - проверка отдельных компонентов
- **Интеграционные тесты** - взаимодействие между компонентами и API
- **Функциональные тесты** - проверка корректности работы алгоритма на задаче маятника
- **Тесты производительности** - оценка скорости и памяти для всех реализаций

## Развёртывание
In development...

(Планируется упаковка в Docker, но нужно разобраться, как это работает)
